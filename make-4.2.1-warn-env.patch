diff -Naur make-4.2.1/expand.c make-4.2.1-modified/expand.c
--- make-4.2.1/expand.c	2017-06-02 18:52:04.803295400 +0300
+++ make-4.2.1-modified/expand.c	2017-06-02 18:52:05.683296700 +0300
@@ -166,6 +166,11 @@
 
   if (v == 0)
     warn_undefined (name, length);
+  else if (v->origin == o_env &&
+    strcmp("GNUMAKEFLAGS", v->name))
+    {
+      warn_env (v->name, v->length);
+    }
 
   /* If there's no variable by that name or it has no value, stop now.  */
   if (v == 0 || (*v->value == '\0' && !v->append))
@@ -323,6 +328,8 @@
                     v = lookup_variable (beg, colon - beg);
                     if (v == 0)
                       warn_undefined (beg, colon - beg);
+                    else if (v->origin == o_env)
+                      warn_env (v->name, v->length);
 
                     /* If the variable is not empty, perform the
                        substitution.  */
diff -Naur make-4.2.1/function.c make-4.2.1-modified/function.c
--- make-4.2.1/function.c	2016-05-21 23:22:32.000000000 +0300
+++ make-4.2.1-modified/function.c	2017-06-02 18:50:50.383191300 +0300
@@ -497,12 +497,20 @@
   struct variable *v = lookup_variable (argv[0], strlen (argv[0]));
 
   if (v == 0)
-    o = variable_buffer_output (o, "undefined", 9);
+    {
+      warn_undefined (argv[0], strlen (argv[0]));
+      o = variable_buffer_output (o, "undefined", 9);
+    }
   else
-    if (v->recursive)
-      o = variable_buffer_output (o, "recursive", 9);
-    else
-      o = variable_buffer_output (o, "simple", 6);
+    {
+      if (v->origin == o_env)
+        warn_env (v->name, v->length);
+
+      if (v->recursive)
+        o = variable_buffer_output (o, "recursive", 9);
+      else
+        o = variable_buffer_output (o, "simple", 6);
+    }
 
   return o;
 }
@@ -1416,7 +1424,14 @@
 
   /* Copy its value into the output buffer without expanding it.  */
   if (v)
-    o = variable_buffer_output (o, v->value, strlen (v->value));
+    {
+      if (v->origin == o_env)
+        warn_env (v->name, v->length);
+
+      o = variable_buffer_output (o, v->value, strlen (v->value));
+    }
+  else
+    warn_undefined (argv[0], strlen (argv[0]));
 
   return o;
 }
@@ -2580,6 +2595,8 @@
 
   if (v == 0)
     warn_undefined (fname, flen);
+  else if (v->origin == o_env)
+    warn_env (v->name, v->length);
 
   if (v == 0 || *v->value == '\0')
     return o;
diff -Naur make-4.2.1/read.c make-4.2.1-modified/read.c
--- make-4.2.1/read.c	2016-05-21 23:22:32.000000000 +0300
+++ make-4.2.1-modified/read.c	2017-06-02 18:50:50.383191300 +0300
@@ -818,7 +818,13 @@
                 {
                   struct variable *v = lookup_variable (p, l);
                   if (v == 0)
-                    v = define_variable_global (p, l, "", o_file, 0, fstart);
+                    {
+                      warn_undefined (p, l);
+                      v = define_variable_global (p, l, "", o_file, 0, fstart);
+                    }
+                  else if (v->origin == o_env && exporting)
+                    warn_env (v->name, v->length);
+
                   v->export = exporting ? v_export : v_noexport;
                 }
 
@@ -1710,6 +1716,10 @@
 
       var[i] = '\0';
       v = lookup_variable (var, i);
+      if (v == 0)
+        warn_undefined (var, i);
+      else if (v->origin == o_env)
+        warn_env (v->name, v->length);
 
       conditionals->ignoring[o] =
         ((v != 0 && *v->value != '\0') == (cmdtype == c_ifndef));
diff -Naur make-4.2.1/variable.c make-4.2.1-modified/variable.c
--- make-4.2.1/variable.c	2016-05-21 23:22:32.000000000 +0300
+++ make-4.2.1-modified/variable.c	2017-06-02 18:50:50.383191300 +0300
@@ -1197,7 +1197,11 @@
          The value is set IFF the variable is not defined yet. */
       v = lookup_variable (varname, strlen (varname));
       if (v)
-        return v->special ? set_special_var (v) : v;
+        {
+          if (v->origin == o_env)
+            warn_env (v->name, v->length);
+          return v->special ? set_special_var (v) : v;
+        }
 
       conditional = 1;
       flavor = f_recursive;
@@ -1229,6 +1233,9 @@
           {
             /* There was no old value.
                This becomes a normal recursive definition.  */
+            if (strcmp(".INCLUDE_DIRS", varname))
+              warn_undefined (varname, strlen (varname));
+
             p = value;
             flavor = f_recursive;
           }
@@ -1240,6 +1247,9 @@
             const char *val;
             char *tp = NULL;
 
+            if (v->origin == o_env)
+              warn_env (v->name, v->length);
+
             val = value;
             if (v->recursive)
               /* The previous definition of the variable was recursive.
@@ -1508,9 +1518,17 @@
                 var->flavor = f_append;
                 break;
               case '?':
+                error (reading_file,
+                  (int)((e ? e : p - 1) - var->name),
+                  _("warning: conditionally-defined variable '%.*s'"), 
+                  (int)((e ? e : p - 1) - var->name), var->name);
                 var->flavor = f_conditional;
                 break;
               case '!':
+                error (reading_file,
+                  (int)((e ? e : p - 1) - var->name),
+                  _("warning: shell-defined variable '%.*s'"), 
+                  (int)((e ? e : p - 1) - var->name), var->name);
                 var->flavor = f_shell;
                 break;
               default:
diff -Naur make-4.2.1/variable.h make-4.2.1-modified/variable.h
--- make-4.2.1/variable.h	2016-05-21 23:22:32.000000000 +0300
+++ make-4.2.1-modified/variable.h	2017-06-02 18:50:50.393191300 +0300
@@ -225,6 +225,14 @@
                                        (int)(l), (n));                  \
                               }while(0)
 
+/* Warn that NAME is an environment-defined variable .  */
+
+#define warn_env(n,l) do{\
+                                error (reading_file, (l),               \
+                                       _("warning: using environment variable '%.*s'"), \
+                                       (int)(l), (n));                  \
+                              }while(0)
+
 char **target_environment (struct file *file);
 
 struct pattern_var *create_pattern_var (const char *target,
